## Виды типизации:

Оригинал:
`id = x -> x`

<ol>
<li>
    Дженерик как параметр функции:
    <pre>id = T: Ty -> x: T -> x</pre>
    <ul><b><i>Плюсы</i></b>:
        <li>
            Не требует дополнительных усложнений конструкций языка, естественный
            способ записи дженериков
        </li>
        <li>
            Позволяет "маркировать"(разделять) разные дженерики
        </li>
    </ul>
    <br>
    <ul><b><i>Минусы</i></b>:
        <li>
            Навязывание ответственности: функции `id` не важно знать, какого конкретно типа `x`,
            ограничения нет, но при таком подходе приходится заморачиваться с дополнительным аргументом
        </li>
        <li>
            Отход от записи нетипизированного Лямбда-Исчисления -> для типизации
            понадобился отдельный аргумент
        </li>
        <li>
            Вряд ли будет использоваться в чистом виде, потребует макросов
            или поддержки языка для более приятной записи
        </li>
    </ul>
</li>
<li>
    Дженерики встроенные в язык через аксиому "A"(any):
    <pre>id = x: T -> x</pre>
    <ul><b><i>Плюсы</i></b>:
        <li>
            Сохраняет вид нетипизированного Лямбда-Исчисления
        </li>
        <li>
            Прост в записи и использовании
        </li>
        <li>
            Позволяет "маркировать"(разделять) разные дженерики
        </li>
    </ul>
    <br>
    <ul><b><i>Минусы</i></b>:
        <li>
            Требует языковой поддержки
        </li>
        <li>
            Неясно, что делать при вызове дженерика внутри тела функции
        </li>
    </ul>
</li>
</ol>
